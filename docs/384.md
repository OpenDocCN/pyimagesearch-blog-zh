# 使用 Keras 和 TensorFlow 可视化网络架构

> 原文：<https://pyimagesearch.com/2021/05/22/visualizing-network-architectures-using-keras-and-tensorflow/>

我们尚未讨论的一个概念是*架构可视化*，即构建网络中节点和相关连接的*图*并将该图保存到磁盘作为图像(即，PNG、JPG 等)的过程。).图中的节点表示层，而节点之间的连接表示网络中的数据流。

这些图表通常包括每个图层的以下组成部分:

1.  *输入*音量大小。
2.  *输出*音量大小。
3.  以及可选的层的*名称*。

我们通常在以下情况下使用网络体系结构可视化:( 1)调试我们自己的定制网络体系结构;( 2)发布，在这种情况下，体系结构的可视化比包含实际源代码或试图构建表格来传达相同信息更容易理解。在本教程的剩余部分，您将学习如何使用 Keras 构建网络架构可视化图形，然后将图形作为实际图像序列化到磁盘。

**要了解如何**使用 Keras 和 TensorFlow** ，*可视化网络架构，请继续阅读。***

## **建筑可视化的重要性**

可视化一个模型的架构是一个关键的调试工具，*尤其是*如果你是:

1.  在出版物中实现体系结构，但不熟悉它。
2.  实现您自己的定制网络架构。

简而言之，网络可视化*验证了我们的假设*,即我们的代码正在正确地构建我们想要构建的模型。通过检查输出图形图像，您可以看到您的逻辑中是否有缺陷。最常见的缺陷包括:

1.  网络中的图层排序不正确。
2.  假设在`CONV`或`POOL`层之后有一个(不正确的)输出音量大小。

每当实现一个网络架构时，我建议您在每一个`CONV`和`POOL`层的块之后都要可视化网络架构，这将使您能够验证您的假设(更重要的是，在早期捕捉网络中的“bug”)。

卷积神经网络中的错误不同于应用程序中由边缘情况导致的其他逻辑错误。相反，CNN 很可能训练并获得合理的结果，即使层排序不正确，但是如果你没有*意识到*这个错误已经发生，你可能会报告你的结果，认为你做了一件事，但实际上做了另一件事。

在本教程的剩余部分，我将帮助您可视化您自己的网络架构，以避免这些类型的问题情况。

### **配置您的开发环境**

要遵循这个指南，您需要在您的系统上安装 OpenCV 库。

幸运的是，OpenCV 可以通过 pip 安装:

```
$ pip install opencv-contrib-python
```

**如果你需要帮助为 OpenCV 配置开发环境，我*强烈推荐*阅读我的** [***pip 安装 OpenCV* 指南**](https://pyimagesearch.com/2018/09/19/pip-install-opencv/)——它将在几分钟内让你启动并运行。

### **在配置开发环境时遇到了问题？**

说了这么多，你是:

*   时间紧迫？
*   了解你雇主的行政锁定系统？
*   想要跳过与命令行、包管理器和虚拟环境斗争的麻烦吗？
*   **准备好在您的 Windows、macOS 或 Linux 系统上运行代码*****？***

 *那今天就加入 [PyImageSearch 大学](https://pyimagesearch.com/pyimagesearch-university/)吧！

**获得本教程的 Jupyter 笔记本和其他 PyImageSearch 指南，这些指南是** ***预先配置的*** **，可以在您的网络浏览器中运行在 Google Colab 的生态系统上！**无需安装。

最棒的是，这些 Jupyter 笔记本可以在 Windows、macOS 和 Linux 上运行！

### **安装 graphviz 和 pydot**

要构建我们的网络图并使用 Keras 将其保存到磁盘，我们需要安装`graphviz`先决条件:

在 Ubuntu 上，这很简单:

```
$ sudo apt-get install graphviz
```

在 macOS 上，我们可以通过自制软件安装`graphviz`:

```
$ brew install graphviz
```

一旦安装了`graphviz`库，我们需要安装两个 Python 包:

```
$ pip install graphviz
$ pip install pydot
```

### **可视化 Keras 网络**

用 Keras 可视化网络架构非常简单。要了解这有多简单，请打开一个新文件，将其命名为`visualize_architecture.py`，并插入以下代码:

```
# import the necessary packages
from pyimagesearch.nn.conv import LeNet
from tensorflow.keras.utils import plot_model

# initialize LeNet and then write the network architecture
# visualization graph to disk
model = LeNet.build(28, 28, 1, 10)
plot_model(model, to_file="lenet.png", show_shapes=True)
```

**第 2 行**导入了我们对 LeNet ( **[早期教程](https://pyimagesearch.com/2021/05/22/lenet-recognizing-handwritten-digits/)** )的实现——这是我们将要可视化的网络架构。**第 3 行**从 Keras 导入`plot_model`函数。正如这个函数名所示，`plot_model`负责基于输入模型内部的层构建一个图，然后将这个图写到磁盘上作为一个图像。

在**第 7** 行，我们实例化了 LeNet 架构，就好像我们要将它应用于 MNIST 进行数字分类。这些参数包括输入体积的宽度(28 像素)、高度(28 像素)、深度(1 个通道)和类别标签的总数(10)。

最后，**第 8 行**绘制了我们的`model`并以`lenet.png`的名字保存到磁盘。

要执行我们的脚本，只需打开一个终端并发出以下命令:

```
$ python visualize_architecture.py
```

命令成功存在后，检查您当前的工作目录:

```
$ ls
lenet.png  visualize_architecture.py
```

正如您将看到的，有一个名为`lenet.png`的文件—这个文件是我们实际的网络可视化图形。打开并检查它**(图 2 和图 3** )。

在这里，我们可以看到通过我们的网络的数据流的可视化。每一层都表示为体系结构中的一个节点，然后连接到其他层，最终在应用 softmax 分类器后终止。请注意网络中的每个层如何包括一个`input`和`output`属性——这些值是当*进入*该层时以及在*退出*该层之后各自体积的空间维度的大小。

走过 LeNet 架构，我们看到第一层是我们的`InputLayer`，它接受 28 *×* 28 *×* 1 输入图像。图层输入和输出的空间维度是相同的，因为这只是输入数据的一个“占位符”。

您可能想知道数据形状`(None, 28, 28, 1)`中的`None`代表什么。`None`实际上是我们的批量。当可视化网络架构时，Keras 不知道我们想要的批量大小，所以它保留值为`None`。训练时，该值将变为 32、64、128 等。或我们认为合适的任何批量。

接下来，我们的数据流向第一个`CONV`层，在那里我们学习 28 *×* 28 *×* 1 输入上的 20 个内核。这个第一层`CONV`的输出是 28 *×* 28 *×* 20。由于零填充，我们保留了原始的空间维度，但是通过学习 20 个过滤器，我们改变了体积大小。

激活层跟在`CONV`层之后，根据定义，它不能改变输入音量大小。然而，一个`POOL`操作*可以*减少音量大小——这里我们的输入音量从 28 *×* 28 *×* 20 减少到 14 *×* 14 *×* 20。

第二个`CONV`接受 14 *×* 14 *×* 20 音量作为输入，但随后学习 50 个滤波器，将输出音量大小更改为 14 *×* 14 *×* 50(再次利用零填充来确保卷积本身不会降低输入的宽度和高度)。在另一个`POOL`操作之前应用激活，该操作再次将宽度和高度从 14 *×* 14 *×* 50 减半至 7 *×* 7 *×* 50。

在这一点上，我们准备好应用我们的`FC`层。为了实现这一点，我们的 7 *×* 7 *×* 50 输入被展平为一系列*2450*值(因为 7*×*7*×*50 = 2*，* 450)。既然我们已经展平了网络卷积部分的输出，我们可以应用一个接受 2450 个输入值并学习 500 个节点的`FC`层。接着是激活，接着是另一个`FC`层，这次将 500 个减少到 10 个(MNIST 数据集的类标签总数)。

最后，将 softmax 分类器应用于 10 个输入节点中的每一个，给出我们最终的分类概率。

## **总结**

正如我们可以用代码表达 LeNet 架构一样，我们也可以将模型本身可视化为图像。当你开始你的深度学习之旅时，我*强烈鼓励*你使用这个代码来可视化你正在工作的任何网络，*尤其是*如果你不熟悉它们的话。确保您了解网络中的数据流以及卷大小如何基于`CONV`、`POOL`和`FC`层发生变化，这将使您对架构有更加深入的了解，而不仅仅是依赖代码。

当实现我自己的网络架构时，我通过每 2-3 个层块*可视化架构来验证我是否在正确的轨道上，因为我实际上是在对网络*进行编码——这个动作帮助我在早期发现我的逻辑中的错误或缺陷。

**要下载这篇文章的源代码(并在未来教程在 PyImageSearch 上发布时得到通知)，*只需在下面的表格中输入您的电子邮件地址！****